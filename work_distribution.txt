Rui:
- Caesar-cipher (priority) -errors GO,  python. pascal isn't possible (string limitation). php,rust no decode. racket wrong implementation
- Binary-search
- Factors-of-an-integer



Saraiva:
- Sorting-algorithms-Quicksort (priority)

  done: C,OCaml,Haskell,Java,Pascal,Python,Perl,Lua,Go,
        JavaScript,Rust,Racket,Erlang,Common-Lisp,Ruby,Dart

- Sorting-algorithms-Merge-sort (priority)

  done: C,OCaml,Haskell,Java,Pascal,Python,Perl,Lua,Go,
        Rust,Racket,Erlang,Common-Lisp,Ruby

- Guess-the-number
- Least-common-multiple


João Paulo:
- Towers-of-Hanoi (priority)
- Binary-digits
- Arithmetic-geometric-mean


Marco:
- Remove-duplicate-elements (priority)
- Factorial
- Sieve-of-Eratosthenes


Francisco:
- Ackermann-function (priority)
* working: Ada, C, C++, Chapel, Erlang, Go, Haskell, Lua, OCaml, Perl, PHP, Racket, Rust, Swift.

- ABC-Problem
* working: C, Python, Erlang, Go, Perl, Racket.
* Go and C are too fast, so they need multiple iterations in order to run for more than 1 second.

- Greatest-element-of-a-list
* working: C, C++, Python, Dart, Go, Pascal
* C, C++, Go and Pascal are REALLY fast (finishing in about 10 ms for 1 million elements already). These ones need lots of iterations, which drastically increases test duration for the other ones. Maybe we should skip this problem.

Rua:
- Greatest-common-divisor -> check
working (status ==0 ) -> for f in $(find ./Greatest-common-divisor/ -maxdepth 1 -type d ) ; do echo "$f -> $(cat $f/status.txt)" ; done
- N-queens-problem (priority) -> (almost)
same
- 100-doors -> check
same

Jácome:
- Fibonacci-sequence
* all done with recursive version using as input the number 46 (biggest Ada could handle); it doesn't need to be runned repeated time as with 46 most languages take a few seconds to conclude
* for C, C++, Chapel did my own implementation as rosetta didn't have a recursive one
* for Common Lisp used the makefile from the PL paper 

- Hailstone-sequence
* done; everything works
